package vulnerability

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/anchore/imgbom/imgbom/distro"
	"github.com/anchore/imgbom/imgbom/pkg"
	"github.com/anchore/vulnscan-db/pkg/db"
	"github.com/anchore/vulnscan/vulnscan/version"
)

type StoreProvider struct {
	store db.VulnStore
	// TODO: allows the ability to have a db cache for keeping rich objects around
	// or to have a sync.Pool of warm objects
}

func NewProviderFromStore(store db.VulnStore) *StoreProvider {
	return &StoreProvider{
		store: store,
	}
}

func (pr *StoreProvider) GetByDistro(d distro.Distro, p *pkg.Package) ([]*Vulnerability, error) {
	vulns := make([]*Vulnerability, 0)

	namespace := distroNamespace(d)
	allPkgVulns, err := pr.store.Get(namespace, p.Name)
	if err != nil {
		return nil, fmt.Errorf("provider failed to fetch namespace='%s' pkg='%s': %w", namespace, p.Name, err)
	}

	for _, vuln := range allPkgVulns {
		format := version.ParseFormat(vuln.VersionFormat)

		// TODO: delete me, this should be implemented in the vulnscan-db repo
		var prefix string
		if vuln.Version == "None" {
			vuln.Version = ""
		}
		if format == version.DpkgFormat && vuln.Version != "" {
			prefix = "< "
		}
		// </TODO>

		constraint, err := version.GetConstraint(prefix+vuln.Version, format)
		if err != nil {
			return nil, fmt.Errorf("provider failed to parse distro='%s' constraint='%s' format='%s': %w", d, vuln.Version, format, err)
		}

		vulns = append(vulns, &Vulnerability{
			Constraint: constraint,
			ID:         vuln.VulnerabilityID,
		})
	}

	return vulns, nil
}

func (pr *StoreProvider) GetByLanguage(l pkg.Language, p *pkg.Package) ([]*Vulnerability, error) {
	vulns := make([]*Vulnerability, 0)

	namespaces := languageNamespaces(l)
	if namespaces == nil {
		return nil, fmt.Errorf("no store namespaces found for language '%s'", l)
	}

	for _, namespace := range namespaces {
		allPkgVulns, err := pr.store.Get(namespace, p.Name)
		if err != nil {
			return nil, fmt.Errorf("provider failed to fetch namespace='%s' pkg='%s': %w", namespace, p.Name, err)
		}

		for _, vuln := range allPkgVulns {
			format := version.ParseFormat(vuln.VersionFormat)

			// TODO: delete me, this should be implemented in the vulnscan-db repo
			if format == version.SemanticFormat && vuln.Version != "" {
				vuln.Version = forceSemVerConstraint(vuln.Version)
			}
			// </TODO>

			constraint, err := version.GetConstraint(vuln.Version, format)
			if err != nil {
				return nil, fmt.Errorf("provider failed to parse language='%s' constraint='%s' format='%s': %w", l, vuln.Version, format, err)
			}

			vulns = append(vulns, &Vulnerability{
				Constraint: constraint,
				ID:         vuln.VulnerabilityID,
			})
		}
	}

	return vulns, nil
}

// match examples:
// >= 5.0.0
// <= 6.1.2.beta
// >= 5.0.0
// < 6.1
// > 5.0.0
// >=5
// <6
var forceSemVerPattern = regexp.MustCompile(`[><=]+\s*[^<>=]+`)

// TODO: delete me once implemented in vulnscan-db
func forceSemVerConstraint(ver string) string {
	return strings.Join(forceSemVerPattern.FindAllString(ver, -1), ", ")
}
