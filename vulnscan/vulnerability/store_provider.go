package vulnerability

import (
	"fmt"
	"strings"

	"github.com/anchore/imgbom/imgbom/distro"
	"github.com/anchore/imgbom/imgbom/pkg"
	"github.com/anchore/vulnscan-db/pkg/db"
	"github.com/anchore/vulnscan/vulnscan/version"
)

type StoreProvider struct {
	store db.VulnStore
	// TODO: allows the ability to have a db cache for keeping rich objects around
	// or to have a sync.Pool of warm objects
}

func NewProviderFromStore(store db.VulnStore) *StoreProvider {
	return &StoreProvider{
		store: store,
	}
}

func (pr *StoreProvider) GetByDistro(d distro.Distro, p *pkg.Package) ([]*Vulnerability, error) {
	vulns := make([]*Vulnerability, 0)

	namespace := distroNamespace(d)
	allPkgVulns, err := pr.store.Get(namespace, p.Name)
	if err != nil {
		return nil, fmt.Errorf("provider failed to fetch namespace='%s' pkg='%s': %w", namespace, p.Name, err)
	}

	for _, vuln := range allPkgVulns {
		format := version.ParseFormat(vuln.VersionFormat)

		// TODO: delete me, this should be implemented in the vulnscan-db repo
		var prefix string
		if format == version.DpkgFormat && vuln.Version != "" {
			prefix = "< "
		}
		// </TODO>

		constraint, err := version.GetConstraint(prefix+vuln.Version, format)
		if err != nil {
			return nil, fmt.Errorf("provider failed to parse constraint='%s' format='%s': %w", vuln.Version, format, err)
		}

		vulns = append(vulns, &Vulnerability{
			Constraint: constraint,
			ID:         vuln.VulnerabilityID,
		})
	}

	return vulns, nil
}

func distroNamespace(d distro.Distro) string {
	return fmt.Sprintf("%s:%s", strings.ToLower(d.Type.String()), d.FullVersion())
}
