package vulnerability

import (
	"fmt"
	"strings"

	"github.com/anchore/imgbom/imgbom/distro"
	"github.com/anchore/imgbom/imgbom/pkg"
	"github.com/anchore/vulnscan-db/pkg/db"
	"github.com/anchore/vulnscan/vulnscan/version"
)

type Provider interface {
	GetByDistro(distro.Distro, *pkg.Package) ([]*Vulnerability, error)
}

type StoreProvider struct {
	store db.VulnStore
	// TODO: allows the ability to have a db cache for keeping rich objects around
	// or to have a sync.Pool of warm objects
}

func NewProviderFromStore(store db.VulnStore) *StoreProvider {
	return &StoreProvider{
		store: store,
	}
}

func (pr *StoreProvider) GetByDistro(o distro.Distro, p *pkg.Package) ([]*Vulnerability, error) {
	vulns := make([]*Vulnerability, 0)

	namespace := pr.osNamespace(o)
	allPkgVulns, err := pr.store.Get(namespace, p.Name)
	if err != nil {
		return nil, fmt.Errorf("provider failed to fetch namespace='%s' pkg='%s': %w", namespace, p.Name, err)
	}

	for _, vuln := range allPkgVulns {
		format := version.ParseFormat(vuln.VersionFormat)

		constraint, err := version.GetConstraint(vuln.Version, format)
		if err != nil {
			return nil, fmt.Errorf("provider failed to parse constraint='%s' format='%s': %w", vuln.Version, format, err)
		}

		vulns = append(vulns, &Vulnerability{
			Constraint: constraint,
			ID:         vuln.VulnerabilityID,
		})
	}

	return vulns, nil
}

func (pr *StoreProvider) osNamespace(o distro.Distro) string {
	return fmt.Sprintf("%s:%d", strings.ToLower(o.Type.String()), o.MajorVersion())
}
