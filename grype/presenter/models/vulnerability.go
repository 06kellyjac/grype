package models

import (
	"github.com/anchore/grype/grype/match"
	"github.com/anchore/grype/grype/vulnerability"
)

type Vulnerability struct {
	ID             string   `json:"id"`
	Severity       string   `json:"severity,omitempty"`
	Links          []string `json:"links,omitempty"`
	Description    string   `json:"description,omitempty"`
	Cvss           []Cvss   `json:"cvss,omitempty"`
	FixedInVersion string   `json:"fixedInVersion,omitempty"`
}

type Cvss struct {
	Version        string      `json:"version"`
	Vector         string      `json:"vector"`
	Metrics        CvssMetrics `json:"metrics"`
	VendorMetadata interface{} `json:"vendorMetadata,omitempty"`
}

type CvssMetrics struct {
	BaseScore           float64  `json:"baseScore"`
	ExploitabilityScore *float64 `json:"exploitabilityScore,omitempty"`
	ImpactScore         *float64 `json:"impactScore,omitempty"`
}

func NewVulnerability(m match.Match, metadata *vulnerability.Metadata) Vulnerability {
	if metadata == nil {
		return Vulnerability{
			ID: m.Vulnerability.ID,
		}
	}

	// nolint:prealloc
	var cvss []Cvss
	for _, score := range metadata.Cvss {
		cvss = append(cvss, Cvss{
			Version: score.Version,
			Vector:  score.Vector,
			Metrics: CvssMetrics{
				BaseScore:           score.Metrics.BaseScore,
				ExploitabilityScore: score.Metrics.ExploitabilityScore,
				ImpactScore:         score.Metrics.ImpactScore,
			},
			VendorMetadata: score.VendorMetadata,
		})
	}

	return Vulnerability{
		ID:             m.Vulnerability.ID,
		Severity:       metadata.Severity,
		Links:          metadata.Links,
		Description:    metadata.Description,
		Cvss:           cvss,
		FixedInVersion: m.Vulnerability.FixedInVersion,
	}
}

func NewCvssMetrics(baseScore, exploitabilityScore, impactScore float64) CvssMetrics {
	return CvssMetrics{
		BaseScore:           baseScore,
		ExploitabilityScore: &exploitabilityScore,
		ImpactScore:         &impactScore,
	}
}
